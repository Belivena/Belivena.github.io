[{"title":"单元测试，集成测试","date":"2017-07-12T02:32:30.000Z","path":"2017/07/12/test1/","text":"一、单元测试定义： 单元测试（又称为模块测试）是针对程序模块(软件设计的最小单位)来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 单元测试任务包括： 1.模块接口测试； 2.模块局部数据结构测试； 3.模块边界条件测试； 4.模块中所有独立执行通路测试； 5.模块的各条错误处理通路测试。 单元测试过程 一般认为单元测试应紧接在编码之后，当源程序编制完成并通过复审和编译检查，便可开始单元测试。测试用例的设计应与复审工作相结合，根据设计信息选取测试数据，将增大发现上述各类错误的可能性。在确定测试用例的同时，应给出期望结果。 应为测试模块开发一个驱动模块（driver）和（或）若干个桩模块（stub）,下图显示了一般单元测试的环境。驱动模块在大多数场合称为“主程序”，它接收测试数据并将这些数据传递到被测试模块，被测试模块被调用后，“主程序”打印“进入-退出”消息。 驱动模块和桩模块是测试使用的软件，而不是软件产品的组成部分，但它需要一定的开发费用。若驱动和桩模块比较简单，实际开销相对低些。遗憾的是，仅用简单的驱动模块和桩模块不能完成某些模块的测试任务，这些模块的单元测试只能采用下面讨论的综合测试方法。 提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。集成测试：在单元测试的基础上，将模块按照设计要求组装进行测试。一般包括逻辑关系检查、数据关系检查、业务关系检查、模块间接口检查、外部接口检查。 二、集成测试定义：集成测试也叫组装测试、联合测试、子系统测试或部件测试。集成测试是在单元测试的基础上，将所有模块按照概要设计要求组装成为子系统或系统。 集成测试的关注点：1.在把各个模块连接起来时，穿越模块接口的数据是否会丢失。 2.各个子功能组合起来，能否达到预期的要求的父功能。 3.一个模块的功能是否会对另一个模块的功能产生不利的影响。 4.全局数据结构是否有问题，会不会被异常修改。 5.单个模块的误差积累起来，是否会放大，从而达到不可接受的程度。 单集成测试的模式：1、非增殖式集成方式。先分别测试每个模块，再把所有模块按设计要求一次全部组装起来所要的系统，然后进行整体测试。使用这种方式可能发现一大堆错误，但为每个错误定位和纠正非常困难，并且在改正一个错误的同时又可能引入新的错误，新旧错误混杂，更难断定出错的原因和位置。 2、增殖式集成方式。又称渐增式集成方式。首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。最后通过增殖逐步组装成为要求的软件系统。 常用的增殖方法有：自顶向下集成测试、自底向上集成测试、核心集成测试等。 自顶向下的增殖方式：将模块按系统程序结构，沿控制层次自顶向下进行集成。由于这种增殖方式在测试过程中较早地验证了主要的控制和判断点。在一个功能划分合理的程序结构中，判断常出现在较高的层次，较早就能遇到。如果主要控制有问题，尽早发现它能够减少以后的返工。 自底向上的增殖方式：从程序结构的最底层模块开始组装和测试。因为模块是自底向上进行组装，对于一个给定层次的模块，它的子模块(包括子模块的所有下属模块)已经组装并测试完成，所以不再需要桩模块。在模块的测试过程中需要从子模块得到的信息可以直接运行子模块得到。自顶向下增殖的方式和自底向上增殖的方式各有优缺点。自顶向下增殖方式的缺点是需要建立桩模块。要使桩模块能够模拟实际子模块的功能将是十分困难的。同时涉及复杂算法和真正输入/输出的模块一般在底层，它们是最容易出问题的模块，到组装和测试的后期才遇到这些模块，一旦发现问题，导致过多的回归测试。而自顶向下增殖方式的优点是能够较早地发现在主要控制方面的问题。自底向上增殖方式的缺点是“程序一直未能做为一个实体存在，直到最后一个模块加上去后才形成一个实体”。就是说，在自底向上组装和测试的过程中，对主要的控制直到最后才接触到。但这种方式的优点是不需要桩模块，而建立驱动模块一般比建立桩模块容易，同时由于涉及到复杂算法和真正输入/输出的模块最先得到组装和测试，可以把最容易出问题的部分在早期解决。此外自底向上增殖的方式可以实施多个模块的并行测试。 核心集成测试：核心系统先行集成测试法的思想是先对核心软件部件进行集成测试，在测试通过的基础上再按各外围软件部件的重要程度逐个集成到核心系统中。每次加入一个外围软件部件都产生一个产品基线，直至最后形成稳定的软件产品。核心系统先行集成测试法对应的集成过程是一个逐渐趋于闭合的螺旋形曲线，代表产品逐步定型的过程。","content":"<p><img src=\"/2017/07/12/test1/test1_1.jpg\" alt=\"测试\"></p>\n<h2 id=\"一、单元测试\"><a href=\"#一、单元测试\" class=\"headerlink\" title=\"一、单元测试\"></a>一、单元测试</h2><h3 id=\"定义：\"><a href=\"#定义：\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>   单元测试（又称为模块测试）是针对程序模块(软件设计的最小单位)来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>\n<h3 id=\"单元测试任务包括：\"><a href=\"#单元测试任务包括：\" class=\"headerlink\" title=\"单元测试任务包括：\"></a>单元测试任务包括：</h3><p>   1.模块接口测试；<br>   2.模块局部数据结构测试；<br>   3.模块边界条件测试；<br>   4.模块中所有独立执行通路测试；<br>   5.模块的各条错误处理通路测试。</p>\n<h3 id=\"单元测试过程\"><a href=\"#单元测试过程\" class=\"headerlink\" title=\"单元测试过程\"></a>单元测试过程</h3><p>　　一般认为单元测试应紧接在编码之后，当源程序编制完成并通过复审和编译检查，便可开始单元测试。测试用例的设计应与复审工作相结合，根据设计信息选取测试数据，将增大发现上述各类错误的可能性。在确定测试用例的同时，应给出期望结果。<br>　　应为测试模块开发一个驱动模块（driver）和（或）若干个桩模块（stub）,下图显示了一般单元测试的环境。驱动模块在大多数场合称为“主程序”，它接收测试数据并将这些数据传递到被测试模块，被测试模块被调用后，“主程序”打印“进入-退出”消息。<br>　　驱动模块和桩模块是测试使用的软件，而不是软件产品的组成部分，但它需要一定的开发费用。若驱动和桩模块比较简单，实际开销相对低些。遗憾的是，仅用简单的驱动模块和桩模块不能完成某些模块的测试任务，这些模块的单元测试只能采用下面讨论的综合测试方法。<br>　　提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。集成测试：在单元测试的基础上，将模块按照设计要求组装进行测试。一般包括逻辑关系检查、数据关系检查、业务关系检查、模块间接口检查、外部接口检查。</p>\n<h2 id=\"二、集成测试\"><a href=\"#二、集成测试\" class=\"headerlink\" title=\"二、集成测试\"></a>二、集成测试</h2><h3 id=\"定义：-1\"><a href=\"#定义：-1\" class=\"headerlink\" title=\"定义：\"></a>定义：</h3><p>集成测试也叫组装测试、联合测试、子系统测试或部件测试。集成测试是在单元测试的基础上，将所有模块按照概要设计要求组装成为子系统或系统。</p>\n<h3 id=\"集成测试的关注点：\"><a href=\"#集成测试的关注点：\" class=\"headerlink\" title=\"集成测试的关注点：\"></a>集成测试的关注点：</h3><pre><code>1.在把各个模块连接起来时，穿越模块接口的数据是否会丢失。\n2.各个子功能组合起来，能否达到预期的要求的父功能。\n3.一个模块的功能是否会对另一个模块的功能产生不利的影响。\n4.全局数据结构是否有问题，会不会被异常修改。\n5.单个模块的误差积累起来，是否会放大，从而达到不可接受的程度。\n</code></pre><h3 id=\"单集成测试的模式：\"><a href=\"#单集成测试的模式：\" class=\"headerlink\" title=\"单集成测试的模式：\"></a>单集成测试的模式：</h3><pre><code>1、非增殖式集成方式。先分别测试每个模块，再把所有模块按设计要求一次全部组装起来所要的系统，然后进行整体测试。使用这种方式可能发现一大堆错误，但为每个错误定位和纠正非常困难，并且在改正一个错误的同时又可能引入新的错误，新旧错误混杂，更难断定出错的原因和位置。\n</code></pre><p>　　2、增殖式集成方式。又称渐增式集成方式。首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。最后通过增殖逐步组装成为要求的软件系统。 常用的增殖方法有：自顶向下集成测试、自底向上集成测试、核心集成测试等。<br>　　自顶向下的增殖方式：将模块按系统程序结构，沿控制层次自顶向下进行集成。由于这种增殖方式在测试过程中较早地验证了主要的控制和判断点。在一个功能划分合理的程序结构中，判断常出现在较高的层次，较早就能遇到。如果主要控制有问题，尽早发现它能够减少以后的返工。<br>　　自底向上的增殖方式：从程序结构的最底层模块开始组装和测试。因为模块是自底向上进行组装，对于一个给定层次的模块，它的子模块(包括子模块的所有下属模块)已经组装并测试完成，所以不再需要桩模块。在模块的测试过程中需要从子模块得到的信息可以直接运行子模块得到。<br>自顶向下增殖的方式和自底向上增殖的方式各有优缺点。自顶向下增殖方式的缺点是需要建立桩模块。要使桩模块能够模拟实际子模块的功能将是十分困难的。同时涉及复杂算法和真正输入/输出的模块一般在底层，它们是最容易出问题的模块，到组装和测试的后期才遇到这些模块，一旦发现问题，导致过多的回归测试。而自顶向下增殖方式的优点是能够较早地发现在主要控制方面的问题。自底向上增殖方式的缺点是“程序一直未能做为一个实体存在，直到最后一个模块加上去后才形成一个实体”。就是说，在自底向上组装和测试的过程中，对主要的控制直到最后才接触到。但这种方式的优点是不需要桩模块，而建立驱动模块一般比建立桩模块容易，同时由于涉及到复杂算法和真正输入/输出的模块最先得到组装和测试，可以把最容易出问题的部分在早期解决。此外自底向上增殖的方式可以实施多个模块的并行测试。<br>　　核心集成测试：核心系统先行集成测试法的思想是先对核心软件部件进行集成测试，在测试通过的基础上再按各外围软件部件的重要程度逐个集成到核心系统中。每次加入一个外围软件部件都产生一个产品基线，直至最后形成稳定的软件产品。核心系统先行集成测试法对应的集成过程是一个逐渐趋于闭合的螺旋形曲线，代表产品逐步定型的过程。　　</p>\n","link":"","tags":[{"name":"iTesting","slug":"iTesting","permalink":"//gentlebaymax.com/tags/iTesting/"}]},{"title":"用热爱抵御生活的琐碎","date":"2017-07-11T02:32:30.000Z","path":"2017/07/11/domo/","text":"曾看过一部电影，韩国著名导演李沧东的文艺片《诗》。 主人公美子是一位已经66岁的女人，她没有丈夫，与女儿分开，与读初中的外孙独自生活，靠做钟点工赚点小钱。 日子虽然清贫，但丝毫没有影响她对生活的热爱，时髦的打扮甚至掩饰了岁月在她身上留下的痕迹。 美子酷爱诗歌，不仅经常参加诗歌朗诵会，而且开始学习写诗。她总是留意观察生活中的点滴，捕捉随时可能出现的灵感，然后把它们记录在随身携带的小本上，想要写出美丽的诗歌。 她观察阳光下的树，捡起落在地上的杏子，蹲在地上看路边的小花，捕捉随时可能出现的灵感。生活有痛苦有麻烦，但是她最终用诗歌完成了自我的救赎。 最后，她终于写出了自己的诗： “你在那边还好吗？感到孤独吗？ 日落时天空还会变红吗？鸟儿还在通往树林的路上唱歌吗？ 你能收到我不敢寄出的信吗？我能表达我不敢承认的忏悔吗？ 时间会流逝，玫瑰会枯萎吗？”面对这疲累不定的生活，有人喜欢赏花、喜欢练字，有人热爱阅读，热爱运动…找一样能让你完全放松自我和沉浸进去的事物。 在这全情的投入和享受中，感受到快乐和平静，用这快乐抵抗平凡生活的庸常。","content":"<p><img src=\"/2017/07/11/domo/bag3.jpg\" alt=\"热爱生活\"></p>\n<p>曾看过一部电影，韩国著名导演李沧东的文艺片《诗》。</p>\n<p>主人公美子是一位已经66岁的女人，她没有丈夫，与女儿分开，与读初中的外孙独自生活，靠做钟点工赚点小钱。</p>\n<p>日子虽然清贫，但丝毫没有影响她对生活的热爱，时髦的打扮甚至掩饰了岁月在她身上留下的痕迹。</p>\n<p>美子酷爱诗歌，不仅经常参加诗歌朗诵会，而且开始学习写诗。她总是留意观察生活中的点滴，捕捉随时可能出现的灵感，然后把它们记录在随身携带的小本上，想要写出美丽的诗歌。</p>\n<p>她观察阳光下的树，捡起落在地上的杏子，蹲在地上看路边的小花，捕捉随时可能出现的灵感。生活有痛苦有麻烦，但是她最终用诗歌完成了自我的救赎。</p>\n<p><img src=\"/2017/07/11/domo/bag2.jpg\" alt=\"诗\"></p>\n<p>最后，她终于写出了自己的诗：</p>\n<blockquote>\n<p>“你在那边还好吗？<br>感到孤独吗？ </p>\n<p>日落时天空还会变红吗？<br>鸟儿还在通往树林的路上唱歌吗？ </p>\n<p>你能收到我不敢寄出的信吗？<br>我能表达我不敢承认的忏悔吗？ </p>\n<p>时间会流逝，玫瑰会枯萎吗？”<br>面对这疲累不定的生活，有人喜欢赏花、喜欢练字，有人热爱阅读，热爱运动…找一样能让你完全放松自我和沉浸进去的事物。</p>\n</blockquote>\n<p><em>在这全情的投入和享受中，感受到快乐和平静，用这快乐抵抗平凡生活的庸常。</em></p>\n","link":"","tags":[{"name":"随笔","slug":"随笔","permalink":"//gentlebaymax.com/tags/随笔/"}]},{"title":"pjax: 当ajax遇上pushState","date":"2014-02-12T00:55:00.000Z","path":"2014/02/12/hello/","text":"1$ var pjax = pushState + ajax; 小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片… 一、简介 pushState是html5中提供的方法，用以无刷新的更新浏览器地址栏；如其名称，将新地址push到历史堆栈中用法：pushState(data, title ,url) data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。 二、ajax的纠结历史 一切可以从ajax最擅长的事情说起。ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。 因而，ajax可以无刷新改变页面内容，却无法改变页面的url。 历史问题1 - 如何操控历史当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：体育 - 篮球 -nba -马刺队 - 邓肯当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法： 刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；支持了历史这样的方式貌似比较完善，其实不然。 历史问题2 - 对搜索引擎不友好最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：#!xxx这样hash的url，google也去爬取。称之为hash bang（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。 事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。 三、pjax带来的价值 除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。 ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步： 一个url对应一套数据，有利于SEO；更改数据和url时，只是局部刷新，带来较好的用户体验；兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获） 四、注意事项然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项： 服务器端增加额外处理逻辑服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应1234567Accept:text/html, */*; q=0.01Accept-Encoding:gzip,deflate,sdchConnection:keep-aliveHost:qianduannotes.duapp.comUser-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36X-Requested-With:XMLHttpRequestX-PJAX:true 比如请求头部可以设定一个X-PAJX:true，用以通知服务器。 浏览器兼容 假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：12345678$.support.pjax = window.history &amp;&amp; window.history.pushState// Fallbackif ( !$.support.pjax ) &#123; $.pjax = function( options ) &#123; window.location = $.isFunction(options.url) ? options.url() : options.url &#125; $.fn.pjax = function() &#123; return this &#125;&#125; 本地存储机制无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。 五、参考资料 jquery-pjaxwelefen封装的pjax","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ var pjax = pushState + ajax;</div></pre></td></tr></table></figure>\n<p>小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片…</p>\n<h2 id=\"一、简介-pushState是html5中提供的方法，用以\"><a href=\"#一、简介-pushState是html5中提供的方法，用以\" class=\"headerlink\" title=\"一、简介 pushState是html5中提供的方法，用以\"></a>一、简介 pushState是html5中提供的方法，用以</h2><p>无刷新的更新浏览器地址栏；<br>如其名称，将新地址push到历史堆栈中<br>用法：pushState(data, title ,url)</p>\n<p>data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。<br>正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。</p>\n<h2 id=\"二、ajax的纠结历史-一切可以从ajax最擅长的事情说起。\"><a href=\"#二、ajax的纠结历史-一切可以从ajax最擅长的事情说起。\" class=\"headerlink\" title=\"二、ajax的纠结历史 一切可以从ajax最擅长的事情说起。\"></a>二、ajax的纠结历史 一切可以从ajax最擅长的事情说起。</h2><p>ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。</p>\n<p>因而，ajax可以无刷新改变页面内容，却无法改变页面的url。</p>\n<h4 id=\"历史问题1-如何操控历史\"><a href=\"#历史问题1-如何操控历史\" class=\"headerlink\" title=\"历史问题1 - 如何操控历史\"></a>历史问题1 - 如何操控历史</h4><p>当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：体育 - 篮球 -nba -马刺队 - 邓肯<br>当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。<br>而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：</p>\n<p>刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；<br>支持了历史<br>这样的方式貌似比较完善，其实不然。</p>\n<h4 id=\"历史问题2-对搜索引擎不友好\"><a href=\"#历史问题2-对搜索引擎不友好\" class=\"headerlink\" title=\"历史问题2 - 对搜索引擎不友好\"></a>历史问题2 - 对搜索引擎不友好</h4><p>最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：#!xxx这样hash的url，google也去爬取。称之为hash bang（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。</p>\n<p>事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。</p>\n<h2 id=\"三、pjax带来的价值-除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。\"><a href=\"#三、pjax带来的价值-除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。\" class=\"headerlink\" title=\"三、pjax带来的价值 除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。\"></a>三、pjax带来的价值 除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。</h2><p>回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。</p>\n<p>ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：</p>\n<p>一个url对应一套数据，有利于SEO；<br>更改数据和url时，只是局部刷新，带来较好的用户体验；<br>兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；<br>刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；<br>后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）</p>\n<h2 id=\"四、注意事项\"><a href=\"#四、注意事项\" class=\"headerlink\" title=\"四、注意事项\"></a>四、注意事项</h2><p>然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：</p>\n<p>服务器端增加额外处理逻辑<br>服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Accept:text/html, *<span class=\"comment\">/*; q=0.01</span></div><div class=\"line\">Accept-Encoding:gzip,deflate,sdch</div><div class=\"line\">Connection:keep-alive</div><div class=\"line\">Host:qianduannotes.duapp.com</div><div class=\"line\">User-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36</div><div class=\"line\">X-Requested-With:XMLHttpRequest</div><div class=\"line\">X-PJAX:true</div></pre></td></tr></table></figure></p>\n<p>比如请求头部可以设定一个X-PAJX:true，用以通知服务器。</p>\n<p>浏览器兼容 假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.support.pjax = window.history &amp;&amp; window.history.pushState</div><div class=\"line\">// Fallback</div><div class=\"line\"><span class=\"keyword\">if</span> ( !$.support.pjax ) &#123;</div><div class=\"line\">  $.pjax = <span class=\"keyword\">function</span>( options ) &#123;</div><div class=\"line\">    window.location = $.isFunction(options.url) ? options.url() : options.url</div><div class=\"line\">  &#125;</div><div class=\"line\">  $.fn.pjax = <span class=\"function\"><span class=\"title\">function</span></span>() &#123; <span class=\"built_in\">return</span> this &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>本地存储机制<br>无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。</p>\n<h2 id=\"五、参考资料-jquery-pjax\"><a href=\"#五、参考资料-jquery-pjax\" class=\"headerlink\" title=\"五、参考资料 jquery-pjax\"></a>五、参考资料 jquery-pjax</h2><p>welefen封装的pjax</p>\n","link":"","tags":[{"name":"js","slug":"js","permalink":"//gentlebaymax.com/tags/js/"},{"name":"html5","slug":"html5","permalink":"//gentlebaymax.com/tags/html5/"}]}]