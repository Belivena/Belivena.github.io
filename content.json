{"meta":{"title":"何李杰的博客","subtitle":"原则做事，温度待人","description":null,"author":"DreamList","url":"//gentlebaymax.com"},"pages":[{"title":"","date":"2017-07-06T12:08:27.012Z","updated":"2017-05-31T16:41:06.000Z","comments":true,"path":"README.html","permalink":"//gentlebaymax.com/README.html","excerpt":"","text":"hexo-theme-yiliaYilia 是为 hexo 2.4+制作的主题。崇尚简约优雅，以及极致的性能。 你可以点击 我的博客 查看效果。 如果想体验手机浏览效果，可以扫一下二维码： ————————————————————— 关于主题： 崇尚简约 追求移动端体验 希望把加载速度做到极致（努力中） 让大家把注意力放到内容上。这是本主题设计初衷 主题不支持IE6，7，8。以后也不会 近期更新（2016.12.04）： 打赏 搜索 “更好的”标签云 “更好的”分享 一些动画 计划中： TOC 移动端优化 一、外观####常规 ####手机 ####ipad横竖屏切换 二、开发者为了性能和开发工程化考虑，Yilia需要使用webpack进行构建生成。 如果您对主题有一些定制化的需求，请参考wiki《Yilia源码目录结构及构建须知》 三、使用安装1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 配置修改hexo根目录下的 _config.yml ： theme: yilia 更新12cd themes/yiliagit pull 四、配置主题配置文件在主目录下的_config.yml，请根据自己需要修改使用。完整配置例子，可以参考我的博客备份 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# Headermenu: 主页: / 随笔: /tags/随笔/# SubNavsubnav: github: \"#\" weibo: \"#\" rss: \"#\" zhihu: \"#\" #qq: \"#\" #weixin: \"#\" #jianshu: \"#\" #douban: \"#\" #segmentfault: \"#\" #bilibili: \"#\" #acfun: \"#\" #mail: \"mailto:litten225@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: # Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: false# 是否在新窗口打开链接open_in_new: false# 打赏# 请在需要打赏的文章的md文件头部，设置属性reward: true# 打赏基础设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 2# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # Miscellaneousbaidu_analytics: ''google_analytics: ''favicon: /favicon.png#你的头像urlavatar:#是否开启分享share_jia: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: false# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#4d4d4d' # 右滑板块背景 slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)'# slider的设置slider: # 是否默认展开tags板块 showTags: false # 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' friends: '友链' aboutme: '关于我'friends: 友情链接1: http://localhost:4000/ 友情链接2: http://localhost:4000/ 友情链接3: http://localhost:4000/ 友情链接4: http://localhost:4000/ 友情链接5: http://localhost:4000/ 友情链接6: http://localhost:4000/aboutme: 很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家"}],"posts":[{"title":"MySQL基本操作","slug":"SQL-2","date":"2017-08-07T04:42:32.000Z","updated":"2017-08-07T05:20:34.138Z","comments":true,"path":"2017/08/07/SQL-2/","link":"","permalink":"//gentlebaymax.com/2017/08/07/SQL-2/","excerpt":"","text":"安装mysql 12345#安装 MySQL 服务端、核心程序sudo apt-get install mysql-server#安装 MySQL 客户端sudo apt-get install mysql-client 验证是否安装并启动成功 1sudo netstat -tap | grep mysql 打开MySQL服务并使用root用户登录： 12345#启动 MySQL 服务sudo service mysql start #使用 root 用户登录，实验楼环境的密码为空，直接回车就可以登录mysql -u root 查看数据库 1show databases; 连接数据库 1use &lt;数据库名&gt; 查看表 1show tables; 查看表中的内容 12SELECT * FROM &lt;表名字&gt;;SELECT * FROM employee; 退出使用命令 quit 或者 exit 退出 MySQL。 创建一个数据库 12CREATE DATABASE &lt;数据库名字&gt;;CREATE DATABASE mysql_shiyan; 新建数据表 12345678CREATE TABLE 表的名字(列名a 数据类型(数据长度),列名b 数据类型(数据长度)，列名c 数据类型(数据长度));CREATE TABLE employee (id int(10),name char(20),phone int(12)); 插入数据 1234INSERT INTO 表的名字(列名a,列名b,列名c) VALUES(值1,值2,值3);INSERT INTO employee(id,name,phone) VALUES(01,'Tom',110110110);INSERT INTO employee VALUES(02,'Jack',119119119);INSERT INTO employee(id,name) VALUES(03,'Rose'); 加载文件中的数据，搭建数据库 1source /home/shiyanlou/Desktop/SQL4/MySQL-04-01.sql 向数据库插入数据 1source /home/shiyanlou/Desktop/SQL4/MySQL-04-02.sql SELECT 语句的基本格式为 12SELECT 要查询的列名 FROM 表名字 WHERE 限制条件;SELECT name,age FROM employee; 数学符号条件 123WHERE限制条件可以有数学符号 (=,&lt;,&gt;,&gt;=,&lt;=) SELECT name,age FROM employee WHERE age&gt;25;SELECT name,age,phone FROM employee WHERE name='Mary'; “AND”与“OR” 12#筛选出 age 小于 25，或 age 大于 30SELECT name,age FROM employee WHERE age&lt;25 OR age&gt;30; IN 和 NOT IN 12SELECT name,age,phone,in_dpt FROM employee WHERE in_dpt IN ('dpt3','dpt4');SELECT name,age,phone,in_dpt FROM employee WHERE in_dpt NOT IN ('dpt1','dpt3'); 通配符_ 和 % 12SELECT name,age,phone FROM employee WHERE phone LIKE '1101__';SELECT name,age,phone FROM employee WHERE name LIKE 'J%'; 对结果排序ORDER BY,关键词ASC和DESC可指定升序或降序排序 1SELECT name,age,salary,phone FROM employee ORDER BY salary DESC; 函数名： COUNT SUM AVG MAX MIN 作用： 计数 求和 求平均值 最大值 最小值 SQL 内置函数和计算 1SELECT MAX(salary) AS max_salary,MIN(salary) FROM employee; 子查询 123SELECT of_dpt,COUNT(proj_name) AS count_project FROM projectWHERE of_dpt IN(SELECT in_dpt FROM employee WHERE name='Tom'); 连接查询 1234SELECT id,name,people_numFROM employee,departmentWHERE employee.in_dpt = department.dpt_nameORDER BY id; 1234SELECT id,name,people_numFROM employee JOIN departmentON employee.in_dpt = department.dpt_nameORDER BY id; 删除数据库 1DROP DATABASE test_01; 重命名一张表 123RENAME TABLE 原名 TO 新名字;ALTER TABLE 原名 RENAME 新名;ALTER TABLE 原名 RENAME TO 新名; 删除一张表 1DROP TABLE 表名字; 在表中增加一列的语句 12ALTER TABLE 表名字 ADD COLUMN 列名字 数据类型 约束;或： ALTER TABLE 表名字 ADD 列名字 数据类型 约束; 12ALTER TABLE employee ADD weight INT(4) DEFAULT 120 AFTER age; #新增一列 weight (体重)放置在 age (年龄)的后面ALTER TABLE employee ADD test INT(10) DEFAULT 11 FIRST;#放在第一列的位置，则使用 FIRST 关键词 删除一列 12ALTER TABLE 表名字 DROP COLUMN 列名字;或： ALTER TABLE 表名字 DROP 列名字; 重命名一列 1ALTER TABLE 表名字 CHANGE 原列名 新列名 数据类型 约束; 改变数据类型 1ALTER TABLE 表名字 MODIFY 列名字 新数据类型; 修改表中某个值 1UPDATE 表名字 SET 列1=值1,列2=值2 WHERE 条件; 删除一行记录 1DELETE FROM 表名字 WHERE 条件; 索引 1234ALTER TABLE 表名字 ADD INDEX 索引名 (列名);CREATE INDEX 索引名 ON 表名字 (列名);ALTER TABLE employee ADD INDEX idx_id (id); #在employee表的id列上建立名为idx_id的索引CREATE INDEX idx_name ON employee (name); #在employee表的name列上建立名为idx_name的索引 视图 12CREATE VIEW 视图名(列a,列b,列c) AS SELECT 列1,列2,列3 FROM 表名字;CREATE VIEW v_emp(v_name,v_age,v_phone) AS SELECT name,age,phone FROM employee; 导入 1LOAD DATA INFILE '文件路径' INTO TABLE 表名字; 导出 12SELECT 列1，列2 INTO OUTFILE '文件路径和文件名' FROM 表名字;SELECT * INTO OUTFILE '/tmp/out.txt' FROM employee;#把整个employee表的数据导出到 /tmp 目录下，导出文件命名为 out.txt 备份 123mysqldump -u root 数据库名&gt;备份文件名; #备份整个数据库mysqldump -u root 数据库名 表名字&gt;备份文件名; #备份整个表mysqldump -u root mysql_shiyan &gt; bak.sql;#备份整个数据库 mysql_shiyan，将备份文件命名为 bak.sql 恢复 1mysql -u root test &lt; bak.sql; #把刚才备份的 bak.sql 恢复到 test 数据库","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"//gentlebaymax.com/tags/MySQL/"},{"name":"SQL语句","slug":"SQL语句","permalink":"//gentlebaymax.com/tags/SQL语句/"}]},{"title":"SQL基础","slug":"SQL-1","date":"2017-08-07T02:53:23.000Z","updated":"2017-08-07T04:43:52.719Z","comments":true,"path":"2017/08/07/SQL-1/","link":"","permalink":"//gentlebaymax.com/2017/08/07/SQL-1/","excerpt":"","text":"一、数据库相关1.1 数据库和SQL概念数据库（Database） 是按照数据结构来组织、存储和管理数据的仓库，它的产生距今已有六十多年。随着信息技术和市场的发展，数据库变得无处不在：它在电子商务、银行系统等众多领域都被广泛使用，且成为其系统的重要组成部分。数据库用于记录数据，使用数据库记录数据可以表现出各种数据间的联系，也可以很方便地对所记录的数据进行增、删、改、查等操作。结构化查询语言(Structured Query Language)简称 SQL 是上世纪 70 年代由 IBM 公司开发，用于对数据库进行操作的语言。更详细地说，SQL是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，同时也是数据库脚本文件的扩展名。 1.2 MySQL介绍MySQL是一个 DBMS（数据库管理系统），由瑞典 MySQLAB 公司开发，目前属于 Oracle 公司，MySQL 是最流行的关系型数据库管理系统（关系数据库，是建立在关系数据库模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据）。由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发者都选择 MySQL 作为网站数据库。MySQL 使用 SQL 语言进行操作。 二、数据类型 数据类型 大小(字节) 用途 格式 INT 4 整数 FLOAT 4 单精度浮点数 DOUBLE 8 双精度浮点数 ENUM 单选,比如性别 ENUM(‘a’,’b’,’c’) SET 多选 SET(‘1’,’2’,’3’) DATE 3 日期 YYYY-MM-DD TIME 3 时间点或持续时间 HH:MM:SS YEAR 1 年份值 YYYY CHAR 0~255 定长字符串 VARCHAR 0~255 变长字符串 TEXT 0~65535 长文本数据 CHAR 和 VARCHAR 的区别: CHAR 的长度是固定的，而 VARCHAR 的长度是可以变化的，比如，存储字符串 “abc”，对于 CHAR(10)，表示存储的字符将占 10 个字节(包括 7 个空字符)，而同样的 VARCHAR(12) 则只占用4个字节的长度，增加一个额外字节来存储字符串本身的长度，12 只是最大值，当你存储的字符小于 12 时，按实际长度存储。 ENUM和SET的区别: ENUM 类型的数据的值，必须是定义时枚举的值的其中之一，即单选，而 SET 类型的值则可以多选。 三、 约束分类 约束类型： 主键 默认值 唯一 外键 非空 关键字： PRIMARY KEY DEFAULT UNIQUE FOREIGN KEY NOT NULL 如下所示，搭建一个成绩管理系统：12345678910111213141516171819202122232425262728293031323334353637383940CREATE DATABASE gradesystem;use gradesystemCREATE TABLE student(sid int(10) PRIMARY KEY,sname CHAR(20) NOT NULL,gender CHAR(6) NOT NULL);CREATE TABLE course(cid int(10) PRIMARY KEY,cname CHAR(20) NOT NULL);CREATE TABLE mark(mid int(10) PRIMARY KEY,sid int(10),cid int(10),score int(3) DEFAULT 0,CONSTRAINT FK_mark_sid FOREIGN KEY (sid) REFERENCES student (sid),CONSTRAINT FK_mark_cid FOREIGN KEY (cid) REFERENCES course (cid));INSERT INTO student VALUES(1, 'Tom', 'male'),(2, 'Jack', 'male'),(3, 'Rose', 'female');INSERT INTO course VALUES(1, 'math'),(2, 'physics'),(3, 'chemistry');INSERT INTO mark VALUES(1, 1, 1, 80),(2, 2, 1, 85),(3, 3, 1, 90),(4, 1, 2, 60),(5, 2, 2, 90),(6, 3, 2, 75),(7, 1, 3, 95),(8, 2, 3, 75),(9, 3, 3, 85);","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"//gentlebaymax.com/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"//gentlebaymax.com/tags/MySQL/"}]},{"title":"Node简介","slug":"git-2","date":"2017-08-04T08:00:40.000Z","updated":"2017-08-04T08:17:32.090Z","comments":true,"path":"2017/08/04/git-2/","link":"","permalink":"//gentlebaymax.com/2017/08/04/git-2/","excerpt":"","text":"一、什么是Node 类似一个操作系统 说到底就是一个JS运行环境 很多的前端开发工具都是基于node这个平台 我们可以在node运行js代码 目前有两个分支 Node.js 0.12.7 官方版本 要求尽善尽美 IO.js 是社区的产物，不是官方的东西，io.js有很多新特性，迭代非常快，社区推进非常快 15年两者合并，发布node第一个正式版 4.0， 迭代速度又慢了 node 5.x == io.js node 4.0 == node 二、什么是NVM Node Version Manager(Node的版本管理工具) 因为node的版本比较多，很多时候我们可能依赖多个版本，并要求自由切换 常用操作： 1234nvm use [对应的版本号] [平台架构（如果是32系统需要写32,64位不用管）]nvm install &lt;version&gt; [arch] 安装nvm uninstall &lt;version&gt; 卸载nvm list 查看已经安装版本 官网 https://github.com/coreybutler/nvm-windows 二、什么是NPM Node Package Manager Node应用程序依赖包的管理工具 安装卸载更新之类的操作 官网 https://www.npmjs.com/ 常用操作：12345// 安装一个包，默认安装最新稳定版本npm install package_name// --save// 初始化操作，给项目添加一个配置文件npm init","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"//gentlebaymax.com/tags/Node/"},{"name":"NPM","slug":"NPM","permalink":"//gentlebaymax.com/tags/NPM/"},{"name":"NVM","slug":"NVM","permalink":"//gentlebaymax.com/tags/NVM/"}]},{"title":"GIT简介","slug":"git-1","date":"2017-08-04T07:20:48.000Z","updated":"2017-08-04T08:19:11.304Z","comments":true,"path":"2017/08/04/git-1/","link":"","permalink":"//gentlebaymax.com/2017/08/04/git-1/","excerpt":"","text":"一、什么是GIT 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 源代码有必要管理起来 让源代码可以被追溯，主要记录每次变更了什么，谁主导这次变化 人为的维护比较麻烦 GIT是Linux之父当年为了维护管理Linux的源代码写的一个工具 Git 之前 很多使用 svn vss tfs hs …… https://guides.github.com/ 二、安装GIT git命令行工具 基于git命令行的一个客户端软件（提供一个界面去管理源代码） 三、GIT命令操作 四、github https://github.com/ GITHUB是一个GIT服务的提供商， 提出社交化编程 五、git的使用流程1、初始化一个本地GIT仓储1234// 定位到仓储文件夹目录$ cd /dir// 初始化本地仓储$ git init 2、添加本地GIT忽略清单文件.gitignore12// 添加OS X中系统文件.DS_Store到忽略清单，这将忽略项目任意目录下的.DS_Store文件或是文件夹$ echo .DS_Store &gt;&gt; .gitignore 3、查看本地仓储的变更状态1$ git status 4、添加本地暂存（托管）文件123456// 添加指定文件名的文件$ git add README.md// 添加通配符匹配的文件$ git add *.md// 添加所有未托管的文件（忽略.gitignore清单中的列表）$ git add --all 5、提交被托管的文件变化到本地仓储1$ git commit -m 'Initial commit(change log)' 6、为仓储添加远端（服务器端）地址1234// 添加一个远端地址并起了一个别名叫origin$ git remote add origin https://github.com/Micua/Git.git// 查看现有的远端列表$ git remote -v 7、将本地仓储的提交记录推送到远端的master分支1$ git push -u origin master 8、拉取远端master分支的更新记录到本地1$ git pull origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"//gentlebaymax.com/tags/git/"}]},{"title":"排序算法——冒泡排序","slug":"algorithm-3","date":"2017-08-01T07:53:00.000Z","updated":"2017-08-04T02:46:40.210Z","comments":true,"path":"2017/08/01/algorithm-3/","link":"","permalink":"//gentlebaymax.com/2017/08/01/algorithm-3/","excerpt":"","text":"一、算法思想（升序排列）从起始元素开始，对数组中两两相邻的元素进行比较，将值较小的元素放在前面，值较大的元素放在后面，一轮比较完毕，一个最大的数沉底成为数组中的最后一个元素，一些较小的数如同气泡一样上浮一个位置（因此成为冒泡或者起泡排序）。n个数，经过n-1轮比较后完成排序。 具体流程如下： 1、对要排序的数组中的数据，依次比较相邻的两个数据的大小。 2、如果前面的数据大于后面的数据，就把这两个数据进行交换。这样一轮比较和交换过后，就把最小的数据放在数组的最前面； 3、按照上述比较和交换的方法，把剩下的数据再进行相同操作，最后，便可按照从小到大的顺序对数组完成排序。 例如：对序列6 5 3 1 8 7 2 4进行冒泡排序的过程如下所示（图片来自维基百科）： 二、代码实现123456789101112131415public void sort(int[] arr) &#123; int tmp; for(int i = 1; i &lt; arr.length; i++) &#123; // 判断相邻两个数据的大小，并把较大的数往后冒泡 for(int j = 0; j &lt; arr.length - 1; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; System.out.println(i + \":\" + Arrays.toString(arr)); &#125; return arr; &#125; 三、算法复杂度和稳定性 平均/最差时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：稳定","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"//gentlebaymax.com/tags/algorithm/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"//gentlebaymax.com/tags/冒泡排序/"}]},{"title":"排序算法——选择排序","slug":"algorithm-2","date":"2017-08-01T07:23:50.000Z","updated":"2017-08-01T08:54:20.998Z","comments":true,"path":"2017/08/01/algorithm-2/","link":"","permalink":"//gentlebaymax.com/2017/08/01/algorithm-2/","excerpt":"","text":"一、算法思想1、首先从原数组中选择最小的1个数据，将其置于第一个位置。2、然后从剩下的数据中再选择其中最小的一个数据，并将其置于原数组的第二个位置。3、不断重复选择和交换的过程，直至最后排序完成。 例如：对序列8 5 2 6 9 3 1 4 0 7进行选择排序的过程如下所示（图片来自维基百科）： 二、代码实现12345678910111213141516171819202122public void sort(int[] arr) &#123; int tmp; // 第n轮排序过程中的较小数的下标 int small; if(num.length &lt; 2) return; for(int i = 0; i &lt; arr.length - 1; i++) &#123; small = i; // 找出最小的数的下标 for(int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[j] &lt; arr[small]) &#123; small = j; &#125; &#125; // 交换 if(small != i) &#123; tmp = arr[i]; arr[i] = arr[small]; arr[small] = tmp; &#125; System.out.println(i + \":\" + Arrays.toString(arr)); &#125;&#125; 三、算法复杂度和稳定性 平均/最差时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：不稳定","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"//gentlebaymax.com/tags/algorithm/"},{"name":"选择排序","slug":"选择排序","permalink":"//gentlebaymax.com/tags/选择排序/"}]},{"title":"排序算法——插入排序","slug":"algorithm-1","date":"2017-08-01T07:06:06.000Z","updated":"2017-08-01T08:50:35.549Z","comments":true,"path":"2017/08/01/algorithm-1/","link":"","permalink":"//gentlebaymax.com/2017/08/01/algorithm-1/","excerpt":"","text":"一、算法思想1、首先比较数组的前两个数据，并排序；2、比较第三个元素与前两个排好序的数据，并将第三个元素放入适当的位置；3、比较第四个元素与前三个排好序的数据，并将第四个元素放入适当的位置；……4、直至把最后一个元素放入适当的位置。 例如：对序列6 5 3 1 8 7 2 4进行插入排序的过程如下所示（图片来自维基百科）： 二、代码实现1234567891011121314151617public void sort(int[] arr) &#123; int tmp; for(int i = 1; i &lt; arr.length; i++) &#123; // 待插入数据 tmp = arr[i]; for(int j = i - 1; j &gt;= 0; j--) &#123; // 判断是否大于tmp，大于则后移一位 if(arr[j] &gt; tmp) &#123; arr[j+1] = arr[j]; &#125;else&#123; break; &#125; &#125; arr[j+1] = tmp; System.out.println(i + \":\" + Arrays.toString(arr)); &#125;&#125; 三、算法复杂度和稳定性 平均/最差时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：稳定","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"//gentlebaymax.com/tags/algorithm/"},{"name":"插入排序","slug":"插入排序","permalink":"//gentlebaymax.com/tags/插入排序/"}]},{"title":"软件测试流程","slug":"test4","date":"2017-07-25T14:23:20.000Z","updated":"2017-08-01T09:07:29.779Z","comments":true,"path":"2017/07/25/test4/","link":"","permalink":"//gentlebaymax.com/2017/07/25/test4/","excerpt":"","text":"一、测试计划设计（系统测试）1.1 目标1.2 总体概述项目背景项目范围 1.3 测试计划测试资源需求软件资源包括：(1) 操作系统资源：windows、linux、unix、MAC；(2) 数据库：SQLServer、Mysql、Oracl、Sybase、DB2；(3) web服务器：IIS、Tomcat、JBOSS、RESIN、Weblogic、Websphere；(4) 需要加版本号。硬件资源：硬件服务器、手机、平板、测试设备。其他设备资源人员要求组织形式测试对象需求跟踪测试通过/失败标准测试挂起/恢复条件测试风险及防范测试时任务安排 1.4 应交付的测试工作产品1.5 资源分配培训需求测试工具开发 二、测试需求分析2.1 分析需求来源需求规格说明书开发需求继承性需求行业竞品分析经验库 2.2 需求分类功能性需求性能需求外部接口需求：GUI、外部应用程序接口需求根据软件质量特性划分需求：安全性、效率、可移植性、可维护。 三、测试策略(测试方案)四、测试规程设计测试需求变更控制流程测试用例变更控制流程测试环境搭建流程缺陷管理流程 五、测试用例设计Excel或者QC 六、配置测试环境分平台：windows、linux、unix；分架构：J2EE（java平台+JSP）、.NET（APSX）、LAMP（PHP）；分web服务器：iis、apache、tomacat、resin、jboss、weblogic、websphere；分数据库：SQL SERVER、MYSQL、ORACLE、DB2、SYBASE； 七、执行测试用例预测试阶段：冒烟测试：利用一袋烟的时间，快速的对被测对象实施测试活动；验证被测对象是否能完成核心功能或高风险功能能否正常工作。预测试结束后需做转系统测试评审；预测试用例来源于系统测试用例设计阶段的高级别的用例。系统测试阶段：经过测试后，开展系统测试；测试执行过程中发现缺陷，则需及时记录缺陷，根据部门或团队的缺陷管理流程进行缺陷提交、跟踪处理。 八、缺陷跟踪回归九、测试报告输出测试日报：(1) 方便测试工程师掌握测试进度和测试情况，用于调整下一天的工作计划；(2) 测试工程师对被测对象每天给出评估结果，用于调整后续工作中的测试策略；(3) 测试经理通过测试日报了解每个测试工程师的工作进度，把握测试整体进度，发现进度上的风险从而及时调整计划；(4) 测试经理通过测试日报，了解各模块缺陷发展趋势，判断测试是否可以退出，通常可利用缺陷管理工具的统计分析功能了解缺陷发现状况；(5) 开发经理根据测试日报了解被测对象质量情况，并可以调整缺陷修改人力资源(6) 如果产品有多个测试组并行测试，测试日报可以提供彼此测试交流的手段。测试报告：(1) 估计软件测试工程师评估当前被测对象的质量，并对下一阶段的测试工作给出建议；(2) 测试经理通过测试报告了解被测试产品的质量情况，测试工程的质量。(3) 软件开发项目经理通过软件测试报告了解产品的质量情况，并在下阶段的开发工作中采取应对措施；(4) 在测试报告中，测试工程师给出的产品质量评估可以作为软件产品是否商用发布的重要参考依据。测试报告模板 十、测试结束活动(1) 检查在测试工程中测试计划中定义的输出物；(2) 缺陷管理是否完成，是否已经进入缺陷管理流程；(3) 测试实施过程中产生的风险报告需要记录；(4) 测试报告是否给出，相关的经验教训是否总结并分享；(5) 是否需要移交测试对象。","categories":[],"tags":[{"name":"iTesting","slug":"iTesting","permalink":"//gentlebaymax.com/tags/iTesting/"},{"name":"测试流程","slug":"测试流程","permalink":"//gentlebaymax.com/tags/测试流程/"}]},{"title":"软件质量","slug":"test3","date":"2017-07-25T12:55:59.000Z","updated":"2017-08-01T09:07:30.810Z","comments":true,"path":"2017/07/25/test3/","link":"","permalink":"//gentlebaymax.com/2017/07/25/test3/","excerpt":"","text":"一、 质量定义质量是物体本身的属性，物体的质量与物体的形状、物态及其所处空间位置无关，质量是物体的一个基本属性。软件产品满足用户或规定显性需求或隐性需求程度。 内部质量 过程质量 外部质量 使用质量 二、 质量特性2.1 功能性定义：软件在指定的使用条件下，满足用户明确和隐含需求的功能的能力。适合性：软件为指定的任务和用户目标提供一组合适功能的能力。准确性： 软件提供具有所需精确度的正确或相符的结果或效果的能力。互操作性： 软件与一个或更多的规定系统进行交互的能力。保密安全性： 软件保护信息和数据的能力，以使未授权的人员或系统不能阅读或修改这些信息和数据，而不拒绝授权人员或系统对他们的访问。功能性依从性： 软件遵循与功能性相关的标准、约定或法规以及类似规定的能力。这些标准要考虑国际标准、国家标准、行业标准、企业内部规范等。 2.2 可靠性定义：软件在指定条件下使用时，维持规定的性能级别的能力。成熟性：软件为避免由软件中错误而导致失效的能力。容错性：在软件出现故障或者违反指定接口的情况下，软件维持规定的性能级别的能力。易恢复性：在失效发生的情况下，软件重建规定的性能级别并恢复受直接影响的数据的能力。可靠性依从性：软件遵循与可靠性相关的标准、约定或法规的能力。 2.3 易用性定义：在指定条件下使用时，软件被理解、学习、使用和吸引用户的能力。易理解性：软件使用户能理解软件是否合适，以及如何能将软件用于特定的任务和使用环境的能力。易学习性：软件使用户能学习其应用的能力。易操作性：软件使用用户能操作和控制它的能力。吸引性：软件吸引用户的能力。易用性依从性：软件遵循与易用性相关的标准、约定、风格指南或法规的能力。这些标准要考虑国际标准、国家标准、行业标准、企业内部规范等。 2.4 效率定义：在规定条件下，相对于所用资源的数量，软件可提供适当性能的能力。时间特性：在规定条件下，软件执行其功能时，提供适当的响应和处理时间以及吞吐率的能力，即完成用户的某个功能需要的响应时间。资源利用性：在规定的条件下，软件执行其功能时，使用合适的资源数量和类别的能力。效率依从性：软件遵循与效率相关的标准、约定或法规的能力。 2.5 可移植性定义：软件可被修改的能力。修改可能包括修正、改进或软件对环境、需求和功能规格说明变化的一种适应性。易分析性：软件诊断软件中的缺陷、失效原因或识别待修改部分的能力。易改变性：软件使指定的修改可以被实现的能力。稳定性：软件避免由于软件修改而造成意外结果的能力。易测试性：软件使已修改软件能被确认的能力。维护性依从性：软件遵循与维护性相关的标准、约定或法规的能力。 2.6 可维护性定义：软件从一种环境迁移到另外一种环境的能力适应性：软件无须采用有别于为考虑该软件的目的而准备的活动或手段，就可能适应不同指定环境的能力。易安装性：软件在指定环境中被安装的能力。共存性：软件在公共环境中同于其分享公共资源的其他独立软件共存的能力。易替换性：软件在同样环境下，替代另一个相同用途的指定软件产品的能力。可移植性依从性：软件遵循与可移植性相关的标准、约定或法规的能力。","categories":[],"tags":[{"name":"iTesting","slug":"iTesting","permalink":"//gentlebaymax.com/tags/iTesting/"},{"name":"测试理论","slug":"测试理论","permalink":"//gentlebaymax.com/tags/测试理论/"}]},{"title":"系统测试类型、软件测试方法","slug":"test2","date":"2017-07-25T12:27:52.000Z","updated":"2017-08-01T09:10:27.075Z","comments":true,"path":"2017/07/25/test2/","link":"","permalink":"//gentlebaymax.com/2017/07/25/test2/","excerpt":"","text":"一、 系统测试类型1.1 功能性测试在指定使用条件下，使用被测对象，验证其是否满足用户显性或隐性需求。测试关注点： 是否有不正确或遗漏多余的功能； 满足系统显性或隐性需求（系统设计的角度）； 是否对输入输出做出了正确的响应，输出结果能否正确的显示。 1.2 性能测试通过模拟被测对象运行业务压力或使用场景，验证被测对象是否满足预先设定的性能指标。验证系统是否具有宣称的能力。了解测试系统典型场景，并具有确定的性能目标。要求在真实环境下实施。 1.3 安全性测试测试被测对象的安全保护机制保护系统不受非法侵入，能够接受正确授权的操作。 1.4 兼容性测试验证被测对象在不同的操作系统、硬件信息等环境下的运行情况。 二、软件测试方法2.1 黑盒测试不关注被测对象内部结构，仅从用户需求考虑，是否满足用户显性或隐性需求。 2.2 白盒测试结构测试、逻辑驱动测试。 2.3 灰盒测试即关注被测对象的外部特征，又关注其内部设计。 2.4 静态测试不执行被测对象程序，不运行被测对象的测试方法。 2.5 动态测试执行被测对象，进行检测。 2.6 手工测试通过测试工程师使用、验证被测对象是否满足用户需求。 2.7 自动化测试通过自动化测试工具，或脚本语言自动化完成测试工程。","categories":[],"tags":[{"name":"iTesting","slug":"iTesting","permalink":"//gentlebaymax.com/tags/iTesting/"},{"name":"测试理论","slug":"测试理论","permalink":"//gentlebaymax.com/tags/测试理论/"}]},{"title":"测试基础","slug":"test1","date":"2017-07-12T02:32:30.000Z","updated":"2017-08-01T09:07:41.388Z","comments":true,"path":"2017/07/12/test1/","link":"","permalink":"//gentlebaymax.com/2017/07/12/test1/","excerpt":"","text":"一、测试定义 通过人工或自动的手段，对被测对象进行检测活动，目的在于发现被测对象是否实现用户的需求，或者弄清实际结果与预测结果之间的差异。 二、 测试目的 发现被测对象与用户需求间的差异—俗称找bug。 通过测试活动发现并解决缺陷，增加人们对被测对象的质量信心。 通过测试活动，获取被测对象的质量信息，为决策提供数据依据。 通过测试活动，预防缺陷，从而降低项目或产品的风险。 三、 测试原则 测试证明软件存在缺陷 不可能执行穷尽测试 测试应该尽早启动，尽早介入 缺陷存在群集现象 杀虫剂悖论 不同的测试活动依赖不同的测试背景 不存在缺陷的谬论 四、 测试对象 软件源代码 与软件源代码匹配的文档 支撑软件源代码运行的配置数据 需求阶段：需求文档—测试需求文档是否正确实现了用户的需求 系统设计阶段：概要设计文档、详细设计文档、是否有设计或逻辑上的错误 编码阶段：测试源代码—发现编程上的错误 系统测试阶段：被测对象是否满足用户需求 五、 测试级别（测试阶段）5.1 单元测试 针对被测系统最小的组成单元实施的测试活动，一般是类或函数，也可能是最小的功能单元。 5.2 集成测试 针对组件/单元与组件/单元之间的接口实施的测试活动，验证接口设计是否与设计相符。分三种集成：函数间集成、模块间集成、子系统间集成。 5.3 系统测试(最常见) 通过集成测试的软件，部署在真实的用户环境下执行测试。 接近用户需求。 通过黑盒测试。 5.4 验收测试 以用户为主的测试，验收组应该由项目组成员、用户代表组成。 α测试—由用户在开发环境下执行的测试活动，开发者在测试人员身边，发现问题及时沟通解决。在受控环境下执行测试。 β测试—开发者不在测试人员身边，发现问题由专人统一收集，再由研发人员进行修改。在不受控环境下执行测试。 UAT测试—用户接受度测试：一般商业用户验证系统可用性进行的测试。","categories":[],"tags":[{"name":"iTesting","slug":"iTesting","permalink":"//gentlebaymax.com/tags/iTesting/"},{"name":"测试理论","slug":"测试理论","permalink":"//gentlebaymax.com/tags/测试理论/"}]},{"title":"用热爱抵御生活的琐碎","slug":"domo","date":"2017-07-11T02:32:30.000Z","updated":"2017-07-25T13:56:12.299Z","comments":true,"path":"2017/07/11/domo/","link":"","permalink":"//gentlebaymax.com/2017/07/11/domo/","excerpt":"","text":"曾看过一部电影，韩国著名导演李沧东的文艺片《诗》。 主人公美子是一位已经66岁的女人，她没有丈夫，与女儿分开，与读初中的外孙独自生活，靠做钟点工赚点小钱。 日子虽然清贫，但丝毫没有影响她对生活的热爱，时髦的打扮甚至掩饰了岁月在她身上留下的痕迹。 美子酷爱诗歌，不仅经常参加诗歌朗诵会，而且开始学习写诗。她总是留意观察生活中的点滴，捕捉随时可能出现的灵感，然后把它们记录在随身携带的小本上，想要写出美丽的诗歌。 她观察阳光下的树，捡起落在地上的杏子，蹲在地上看路边的小花，捕捉随时可能出现的灵感。生活有痛苦有麻烦，但是她最终用诗歌完成了自我的救赎。 最后，她终于写出了自己的诗： “你在那边还好吗？感到孤独吗？ 日落时天空还会变红吗？鸟儿还在通往树林的路上唱歌吗？ 你能收到我不敢寄出的信吗？我能表达我不敢承认的忏悔吗？ 时间会流逝，玫瑰会枯萎吗？”面对这疲累不定的生活，有人喜欢赏花、喜欢练字，有人热爱阅读，热爱运动…找一样能让你完全放松自我和沉浸进去的事物。 在这全情的投入和享受中，感受到快乐和平静，用这快乐抵抗平凡生活的庸常。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"//gentlebaymax.com/tags/随笔/"}]},{"title":"JUnit4中的套件和参数设置","slug":"test-junit2","date":"2016-08-23T11:36:04.000Z","updated":"2017-08-23T11:57:31.655Z","comments":true,"path":"2016/08/23/test-junit2/","link":"","permalink":"//gentlebaymax.com/2016/08/23/test-junit2/","excerpt":"","text":"一、JUnit4中的测试套件 测试套件就是组织测试类一起运行的 写一个作为测试套件入口类，这个类里不包含其他的方法 更改测试运行器Suite.class 将要测试的类作为数组传入到Suite.SuiteClasses({}) 1234567import static org.junit.Assert.*;import org.junit.runner.RunWith;import org.junit.runners.Suite;@RunWith(Suite.class)@Suite.SuiteClasses(&#123;TaskTest1.class,TaskTest2.class,TaskTest3.class&#125;)public class SuitTest &#123; &#125; 二、JUnit4中的参数化设置 更改默认的测试运行器为RunWith(Parameterized.class) 声明变量来存放预期值和结果值 声明一个返回值为Collection的公共静态方法，并使用@Parameters进行修饰 为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量赋值12345678910111213141516171819202122@RunWith(Parameterized.class)public class ParameterTest &#123; int expected = 0; int input1 = 0; int input2 = 0; @Parameters public static Collection&lt;Object[]&gt; t()&#123; return Arrays.asList(new Object[][]&#123; &#123;3,2,1&#125;, &#123;4,2,2&#125; &#125;); &#125; public ParameterTest(int expected,int input1,int input2)&#123; this.expected = expected; this.input1 = input1; this.input2 = input2; &#125; @Test public void tedAdd()&#123; assertEquals(expected, new Calculate().add(input1, input2)); &#125;&#125;","categories":[],"tags":[{"name":"iTesting","slug":"iTesting","permalink":"//gentlebaymax.com/tags/iTesting/"},{"name":"JUnit4","slug":"JUnit4","permalink":"//gentlebaymax.com/tags/JUnit4/"}]},{"title":"JUnit4简介","slug":"test-junit1","date":"2016-08-23T11:35:45.000Z","updated":"2017-08-23T11:55:32.657Z","comments":true,"path":"2016/08/23/test-junit1/","link":"","permalink":"//gentlebaymax.com/2016/08/23/test-junit1/","excerpt":"","text":"一、JUnit的介绍和使用JUnit是一个Java编程语言单元测试框架。JUnit有很重要的发展，测试驱动的开发，是一个统称为xUnit的起源与JUnit的单元测试框架之一。1234 @Testpublic void testAdd() &#123; fail(\"Not yet implemented\");&#125; 测试方法上必须使用@Test进行修饰 测试方法必须使用public void进行修饰，不能带任何的参数 新建一个源代码目录来存放我们测试代码 测试类的包应该和被测试类保持一致 测试单元中的每个方法必须可以独立测试，测试方法间不能有任何的依赖 测试类使用Test作为类名的后缀（不是必须的） 测试方法使用test作为方法的前缀（不是必须的）二、测试失败的两种情况Failure一般是由单元测试使用的断言方法判断失败所引起的，这就表示测试点发现了问题，就是说程序输出的结果和我们预期的不一样error是由代码异常引起的，它可以产生于测试代码本身的错误，也可以是被测试代码中的一个隐藏bug注意：测试用例不是用来证明你是对的，而是用来证明你没有错。三、JUnit的运行流程 @BeforeClass修饰的方法会在所有方法被调用前执行，而且该方法是静态的，所以当测试类被加载后接着就会运行它，而且在内存中它只会存在一份实例，它比较适合加载配置文件。 @AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库的连接 @before和@After会在每个测试方法的前后各执行一次。四、JUnit常用的注解 @BeforeClass它会在所有方法运行前被执行，static修饰。 @AfterClass它会在所有的方法被运行结束后被执行，static修饰。 @before r会在每个测试方法前执行一次。 @After会在每个测试方法后执行一次。 @Test:将一个普通的方法修饰成为一个测试方法 @Test(expected=XX.class) @Test(timeout=毫秒) @Ignore:所修饰的测试方法会被测试运行器忽略 @RunWith:可以更改测试运行器org.junit.runner.Runer1234567891011@Ignore@Test(expected=ArithmeticException.class)public void testDivid()&#123; assertEquals(3, new Calculate().divid(6, 0));&#125;@Test(timeout=2000)public void testWhile()&#123; while(true)&#123; System.out.println(\"run forever\"); &#125;&#125;","categories":[],"tags":[{"name":"iTesting","slug":"iTesting","permalink":"//gentlebaymax.com/tags/iTesting/"},{"name":"JUnit4","slug":"JUnit4","permalink":"//gentlebaymax.com/tags/JUnit4/"}]}]}